第5章 ダックタイピングでコストを削減する
    ダックタイピングとは
     →型付けされたちゃんと設計れたコードのこと？
     →いかなる特定のクラスとも結びつかないパブリックインターフェースのこと
     →メッセージによりゆるーい依存で書かれている。
     →「オブジェクトがアヒルのように鳴きアヒルの様に歩くのならそれはアヒルである」が由来
    5.1 ダックタイピングを理解する
    ダックを見逃す
        Tripクラスのprepareはどんなクラスでも受け取れる。
        Mechanicクラスが受け取り解答を返せるということは依存があるということ。
    問題を悪化させる
        引数から何をするのかを受け取るようにしてみる。
         →caseで各クラスを呼び出すのはあやしい
         →異なる3つのメソッドを参照してるし、それぞれがどのメソッドを走らせるのかを知っているため。
         →追加されると更に依存度上がる。。
        どうすればいいんだ…
         →引数にクラスを追加したらどうか？
         →依存度が爆増する
        具体的なメソッド名に頼り過ぎてる
        シーケンス図が複雑だとコードももっと複雑になるから気を付けよう。設計がおかしい説が濃厚。
    ダックを見つける
        Tripクラスは単一の目的を果たすためにある。
        Tripクラスのprepareメソッドは旅行の準備をすること(prepare)が目的
         →引数も旅行の準備に費やせばよい
        prepareメソッドは引数が複数のPrepareであることを想定している。
        ```
            class Trip 
                def prepare(preparers)
                    preparers.each do |preparer|
                    preparer.prepare_trip(self)

            class Mechanic
                def prepare_trip(trip)
                    trip.bicycles.each do |bicycle|
                    prepare_bicycle(bicycle)
        ```
    ダックタイピングの影響
        ↑の例は分かりにくそうに見えるけど理解さえすれば一番拡張しやすい。
    Column ポリモーフィズム(polymorphism)
        「poly」 1つのメッセージが多くの
        「morphism」 多数の形態を持っている状態
    5.2 ダックを信頼するコードを書く
        ダックタイプの設計で難しいのは
            ・ダックタイプが必要であることに気付くこと
            ・インターフェースを抽象化すること
    隠れたダックを認識する
        よくあるコーディングパターンでダックタイピングを適応できるもの
            ・クラスで分岐するcase文
            ・kind_of?とis_a?
            ・responds_to?
        ●クラスで分岐するcase文
            prepareが引数のそれぞれから何を望むかを考える。
             →準備する(preapare)は旅行(trip)を準備することを望んでいた。
             →prepare_tripはPreparerダックのパブリックインターフェースとなる。
        ●kind_of?とis_a?
            kind_of_とis_a?はクラスを確認するもの
             →case文みたいな感じ、クラス版のtypeOf()って感じ
        ●responds_to?
            メソッド名版のtypeOf()かな？
    ダックを信頼するコードを書く
        信頼とは、あなたが何をするのか知らない状態
    ダックタイプを文書化する
        例ではいろんなクラスがprepare_tripを実装してるからPreparerっていうまとまりで使える。
        ダックタイプと作る時は
            ・パブリックインターフェースの文書化
            ・テスト
        を書く。
        テストは第9章でやります。
    ダック間でコードを共有する
        第7章でやります。
    賢くダックを選ぶ
        なんでこれはよいコードなのか？
        ```
            #このメソッドには < tt > find(: first) </ tt >メソッドと
            #同じ引数をすべて渡せる
            def first(* args)
                if args. any?
                    if args. first. kind_ of?( Integer) || (loaded?&& !args. first. kind_ of?( Hash))
                            to_ a. first(* args)
                        else
                            apply_ finder_ options( args. first). first
                    end
                    else
                        find_ first
                end
            end
        ```
        IntegerやHashクラスはRubyのコアクラスであり変わることがほぼない安全な依存である。
        判断をしなければならない。
        基本クラスに変更を加える 「モンキーパッチ」という。
         →楽しいらしいが慣れないうちにやるとやばめ。
    5.3 ダックタイピングへの恐れを克服する
    静的型付けによるダックタイプの無効化
        型は変数の中身の分類
        静的型付け言語では変数の型とメソッドの引数は明示的に型を宣言する必要がある。
        静的型付け言語は自己強化で好む人が多いね
    静的型付けと動的型付け
        メタプログラミング 「コードを書くコード」
        静的の利点
            ・コンパイラーがコンパイル時にエラーを見つけてくれる
            ・型情報はドキュメントとしても機能する
            ・コンパイルされたコードは高速に動く
            静的支持者はこう考える
                ・コンパイラが型を検査しない限り、実行時の型エラーが起きる。
                ・型がなければコードを理解できない。実装者はコードを見ただけじゃ型を推測できない。
                ・最適化しなければアプリケーションは遅くなりすぎる。
        動的の利点
            ・コードは逐一実行され、動的に読み込まれる。コンパイラのサイクルがない。
            ・コードは明示的な型情報を持たない。
            ・メタプログラミングより簡単
            動的支持者はこう考える
                ・アプリケーション全体の開発はコンパイラがない方が早い
                ・型宣言がないコードの方が理解が楽。コードから型は推測できる。
                ・メタプログラミングはあることが望ましたい言語機能
    動的型付けを受け入れる
        動的に慣れている人は型付けを疎ましく思う。
        静的に慣れている人は型がないと混乱する。
        メタプログラミングはナイフ、利用者によって便利にも凶器にもなる。
         →メタプログラミング支持者は動的支持者でもあるということ？
        コンパイルは対して価値をもたらしてくれないのにコストが高い？
        動的はコンパイルしないからはるかに効率的
         →ダックタイピングは動的の上に成り立つ。
    まとめ