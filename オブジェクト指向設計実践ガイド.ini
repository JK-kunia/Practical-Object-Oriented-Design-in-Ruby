オブジェクト指向設計実践ガイド
第1章 オブジェクト指向設計
    1.1 設計の賞賛
    設計が解決する問題
        生産性と楽しさをどちらも取り入れられる
        変更は絶対ある、それに対応する
    変更が困難な理由
        依存関係を管理する
        依存関係がぐちゃぐちゃだと変更が困難になる
    設計の実用的な定義
        設計とはアトリエ、芸術
        設計の目的は「あとにでも」設計をできるようにし、変更コストを削減すること
    1.2 設計の道具
    設計原則
        SOLIDなどの原則はどこから来た？
        研究者で定量的にデータを取って計測した
            この結果は信じても良いものだぞ、原則に従えば良いコードをかけるぞ
    設計(デザイン)パターン
        デザインパターンが浸透のはよいが、初心者が間違ったパターンを適応して複雑になってるぞ
        この本を読んでパターンを適切に選べ
    1.3 設計の行為
    設計が失敗する原因
        設計を知らなくても作れてしまう、PHP,Rubyなど、誰でも動くものをつくれてしまう
        設計の知識が増えてきた頃が危険、なんでもかんでも新しい知識を使おうとするからな
        アジャイルはいいぞ、必要な要件がなんなのかわかるには時間がかかる場合があるからな、設計を修正しやすいな
    設計をいつ行うか
        顧客にはすぐ見せろ、何が欲しいのかわかってないからな
        最初から全体設計(BUFD)は無理よ、完成時期も予測できないよ
        納期が責任を生む、そしてプロジェクトは崩壊する
        BUFDは作る前から全体を詳細に定義しすぎるから厳しい
        オブジェクト指向設計は小さく小さく行う、アジャイルは変更ある前提で動く
        シンプル、柔軟性、適応性のあるコードを生み出せば成功する
    設計を判断する
        書いたコードの総数(SLOC)昔の生産性の指標 品質は悪いよね
        どれだけオブジェクト指向かを測定してくれるメトリクスがある。バイアスはなく数字を出してくれる。
        妥協してると技術的負債、利子もつくぞ
        利益を生み出すような技術をこの本から学ぼう
    1.4 オブジェクト指向プログラミングのかんたんな導入
    手続き型言語
        非オブジェクト指向
        型があるな、どんな型なのか知ってるのはプログラマー自身だ
        一回送り出したら後何してるか分かんね、幼稚園に送り出した子供の様に
    オブジェクト指向言語
        データとふるまいを1つのオブジェクトに持つ
        concatはRubyは持たない、文字列のオブジェクトが持つ
        クラス 似たようなオブジェクトの構造の設計図
        メソッド(振る舞い) 属性(変数の定義)
        インスタンス化 繰り返し生成して使われる
        固有のデータだけは違う
        文字列オブジェクトの設計図も「それ自体がオブジェクト」である
            Classクラスのオブジェクト Classクラスは新しいクラスを生成している
    第2章　単一責任のクラスを設計する
    2.1 クラスに属するものを決める
    メソッドをグループに分けクラスにまとめる
        メソッドはクラス内に定義される
        クラスはソフトウェアで言う仮想の世界 クラス＝枠組み
        きちんとクラス分けをするが、初期段階は知識が足りなくて無理だな、変更はくわえられるものだ
    変更が簡単なようにコードを組成する
        かんたんとは？TRUEなコードであること、単一の責任を持つこと
        Transparent 見通しが良い 副作用がない
        Reasonable  合理的       要件の変更が小さいならコードの修正も小さい
        Usable      利便性が高い 再利用性
        Exemplary   模範的       コードの変更をする人が↑の品質を自然と保ようになっている
    2.2 単一の責任を持つクラスを作成する
    アプリケーション例: 自転車とギア
        ギアクラスを作ってチェーン/コグでギア比を出すクラスを作った。
        友人の考案により車輪サイズも考慮したら、引数が増えて元々ギアクラスを呼び出してたところでエラーになっちゃった。
        これからも変更が加わるだろうからコードの変更が容易でなければならない。
    なぜ単一責任が重要なのか
        複製はメンテナンス大変
        2つの責任は再利用し辛い
        目的の変更と違うところで影響出るしデグる可能性大
    クラスが単一責任かどうかを見極める
        1文で説明できるもの 「または」はない
        「ギアクラスさん、あなたのギア比を教えてください」
        「ギアクラスさん、あなたの車輪サイズを教えてください」 これでは意味わからん
        単一責任の原則(SRP) 責任駆動設計(RDD)
        「ギアクラスさん、歯のある2つのスプロケット間の日を計算して下さい」 これはやり過ぎている
    設計を決定すると気を見極める
        今の段階ではギアクラスさんをどうすることもできない。
        初期段階のプロジェクトの知識量はとても少ない。
        ギアクラスさんは複製されるべきでも再利用されるべきでもないが、その日が来ることがあるかもしれない。
        現時点での要件と未来の可能性の相互間のトレードオフを理解し、コストが最小になるように決断するのです。
    2.3 変更を歓迎するコードを書く
    データではなく、振る舞いに依存する
        DRY どんな振る舞いも一か所のみに存在すること
        DRYなコードは変更しやすい、１か所だけ変えればいいから
    インスタンス変数の隠蔽
        インスタンス変数はアクセサメソッドで包み直接参照しないようにする。
        メソッドで包むとは？
        パブリックかプライベートでやるべきかは4章でやる
    データ構造の隠蔽
        配列の[0]にタイヤのリアが入っている
        複雑な奴は自身からも？？見えないところに隠そう
    あらゆる箇所を単一責任にする
        クラス以外でも使える概念
    メソッドから余計な責任を抽出する
        メソッドも単一責任であるべき
        wheelsを繰り返し、それぞれの直径を計算している
        →配列を繰り返し処理するメソッドと1つの直径を出すメソッドに分ける
        1文で責任を説明しよう
        コメントが必要なくなる
        再利用できるようになる
        他のクラスへの移動が簡単
    クラス内の余計な責任を隔離する
        余計なふるまいを消したい
        責任あり過ぎたら他のクラスとかに分離する
    2.4 ついに、実際のWheelの完成
        ruby/2章ディレクトリで「reby test.rb」を実行、結果を見れる
    2.5 まとめ
第3章 依存関係を管理する
    3.1 依存関係を認識するする
    依存関係を理解する
        2章終了時点のコード GearのWheelに対する依存は4つある。
        これがあると依存している
            ・GearクラスはWheelクラスの名前を知っている。
            ・GearクラスはWheelクラスがdiameterというメソッドを持っていることを知っている。
            ・GearクラスはWheelクラスをnewするときにrimとtireが引数に必要なことを知っている。
            ・GearクラスはWheelクラスをnewするときに第一引数がrimで第二引数がtireであることを知っている。
        ↑はWheelクラスの変更がGearクラスの変更を強制している。
    オブジェクト間の結合(CBO)
        意外とオブジェクト同士で結合してるから1角オブジェクトだけ再利用っていうのができない。
        絡み合ってるから後々めんどうになる。
    ほかの依存関係
        初心者の書くテストはコードと結合しすぎてリファクタリングのたびに壊れる。
        依存関係を避けるテクニックを↓で紹介していく。
    3.2 疎結合なコードを書く
    依存オブジェクトの注入
        ```
        Gearクラス

        def gear_inches
            ratio * wheel.diameter
        end
        ```
        Wheelクラス(インスタンス)に依存している。
        「Wheelインスタンスのギアインチしか計算する意思はない」と宣言してしまっている。
        Gearはdiameterを知るDuckを要求する。
        Gear.new(52, 11, Wheel.new(26, 1.5)).gear_inchs
        オブジェクト@wheelに保有している
    依存を隔離する
        Wheelクラスはどこに書けばよいのでしょう？
        WheelのnewをGearのinitializeに書いた(最初に呼び出されるやつ)
        →まだまだ依存している。
        →Gearがwheelに依存していることが明確になった。
        →変更がしやすくなった。
    引数の順番への依存を取り除く
        chainring, cog, wheelの引数
        「固定された順番の引数」への依存を簡単に回避する方法。
        →オプションのハッシュ（配列かな）を受け取るようにコードを変える。
        →配列にして渡せってこと
        引数が少ないやつはそのまま使うのがよさそうです。
        明示的にデフォルト値を設定する。「||」の参考演算子を使う。
        論理値(true,false)が渡ってくる引数ならfetchメソッドを使おう。
        →存在しないキーの場合に処理してくれる。
        initializeでデフォルト値を設定して、mergeメソッドで配列をマージする方法もある
        →割と大量の引数を受け取る時とかに有効。
        フレームワークとかで引数固定のものもある。
        →包み隠して使いやすくしてしまおう
        他のオブジェクトを生成する目的のオブジェクトを「ファクトリー」という。
    3.3 依存方向の管理
    依存関係の逆転
        WheelをGearに依存させる。
        メソッドの引数に渡してみた。
        逆にしても問題なさそうに見えるけど、アプリケーションは変化するからどっちに依存させるかも大事だよね。
    依存方向の選択
        「自分より変化しないものに依存しなさい」
        ・あるクラスは、ほかのクラスよりも要件が変わりやすい
        ・具象クラスは抽象クラスよりも変わりやすい
        ・多くのところから依存されたクラスを変更すると、広範囲に影響が及ぶ
第4章 柔軟なインターフェースをつくる 
    4.1 インターフェースを理解する
        任意か橋をさらすか
        前者は再利用不可
        後者は着脱可能
        クラスは何をするかではなくなにを明らかにするか
    4.2 インターフェースを定義する
        厨房とお客さん
        メニューと調理法
        パブリックとプライベート
    パブリックインターフェース
        ・クラスの主要な責任を明らかにする
        ・外部から実行されることが想定される
        ・他社がそこに依存しても安全
        ・テストで完全に文書化されている
    プライベートインターフェース
        ・実装の詳細にかかわる
        ・他のオブジェクトから送られてくることは想定されていない
        ・どんな理由でも変更されうる
        ・他社がそこに依存するのは危険
        ・テストでは、言及さえされないこともある
    責任、依存関係、そしてインターフェース
        パブリックは責任を説明できるべき
        →変更の可能性が低い、パブリックは安定している
        →プライベートは不安定
    4.3 パブリックインターフェースを見つける
    アプリケーション例: 自転車旅行会社
        ・現状は紙管理、自動化したい
        ・ガイドは整備士も兼ねる、ガイドが必要
        ・旅行者はスキルレベルを持っている
        ・自転車の貸し出しもやってる
        ・「難易度、日付、自転車を借りられる旅行の一覧を見たい」というユースケースに答える
        アプリケーションに求めらる要件をユースケースとする
        このユースケースを満足させるために必要なオブジェクトとメッセージの両方について、まず見当をつける
    見当をつける
        設計するど
        最初のテストはむずいよ
        君たちは見当がないやろ
        ・参加者、旅行、行程、自転車、整備士クラスを予想
        →ドメインオブジェクト 大きくてデータベースに表されそうなやつら
        こいつらに惑わられるな、良い方法を↓で紹介するよ。
    シーケンス図を使う
        思考の明確になる
        メッセージをどのクラスからどこに渡すか
        パラメーターが何にするか
        メッセージに基づく設計をしていく
        誰が応答するべきなのかを考え、クラスが足りないなら適切に増やす。
        設計の質問が「このクラスが必要なのは知ってるけど、これは何をすべきか」から「このメッセージを送る必要があるけど、誰が応答すべきか」に変わる
        オブジェクトが存在するからメッセージを送るのではなく、メッセージを送るためにオブジェクトが存在する
    どのようにを伝えるのではなく何を頼む
        Tripとメカニッククラスを良い感じに分けてる
    コンテキストの独立を模索する
        依存オブジェクトの注入
        引数を使う Tripのメカニッククラスへの依存が減った
        オブジェクトがそのコンテキストから独立していることが、ベストな状況
    ほかのオブジェクトを信頼する
        オブジェクト同士が手放しで信頼しあえることが、オブジェクト指向設計の要
        「私は自分が何を望んでいるかを知っているし、あなたがそれをどのようにやるかも知っているよ」
    オブジェクトを見つけるためにメッセージを使う
        TripFinder パブリックインターフェース
        単一責任の原則を破っている場合、新しいオブジェクトが必要
        新しいオブジェクトは、そこにメッセージを送る必要性があったために発見される
    メッセージを基本とするアプリケーションを作る
    4.4 一番いい面(インターフェース)を表に出すコードを書く
    明示的なインターフェースを作る
        パブリックインターフェースに含まれるメソッドは、以下のようであるべき
            ・明示的にパブリックインターフェースだと特定できる
            ・「どのように」よりも、「何を」になっている
            ・名前は、考えられる限り、変わり得ないものである
            ・オプション引数として、ハッシュをとる
        Rubyのpbulic・protected・private
            この3つのキーワードは、全く異なる2つの用途で用いられる
                1つ目は、どのメソッドが安定でどのメソッドが不安定か
                2つ目は、どれだけメソッドが見えるか制御するため
                この3つのキーワードを使うことで、以下2つのことを伝えられる
                    ・「将来の」プログラマーが持つ情報よりも、今の自分の方がより良い情報を持っていると信じている
                    ・今の自分が不安定だと考えているメソッドを、将来のプログラマーに不用意に使われることは防がなければならないと信じている
    4.5 デメテルの法則
    デメテルを定義する
        デルメルの法則は、オブジェクトを疎結合にするためのコーディング規則の集まり
        デルメルの法則に違反すると
            ・パブリックインターフェースの正確な定義と特定ができていない
            ・実害がない場合もある
        「直接の隣人にのみ話しかけよう」
        「ドットは1つしか使わないようにしよう」
            3つ目のオブジェクトにメッセージを送る際、異なる型の2つ目のオブジェクトを介することを禁じる
    法則を違反することによる影響
    違反を回避する
    デメテルに耳を傾ける
        デルメルが伝えたいのは「委譲をもっと使いましょう」ということではない
        「何を」を求めて、メッセージチェーンを再考する
        メッセージに基づく視点に移行してメッセージを見つければ、そのメッセージは自ずと何らかのオブジェクトのパブリックインターフェースとなる
        そのオブジェクトが何のオブジェクトなのかは、メッセージ自体が導いてくれる
    まとめ
第5章 ダックタイピングでコストを削減する
    ダックタイピングとは
     →型付けされたちゃんと設計れたコードのこと？
     →いかなる特定のクラスとも結びつかないパブリックインターフェースのこと
     →メッセージによりゆるーい依存で書かれている。
     →「オブジェクトがアヒルのように鳴きアヒルの様に歩くのならそれはアヒルである」が由来
    5.1 ダックタイピングを理解する
    ダックを見逃す
        Tripクラスのprepareはどんなクラスでも受け取れる。
        Mechanicクラスが受け取り解答を返せるということは依存があるということ。
    問題を悪化させる
        引数から何をするのかを受け取るようにしてみる。
         →caseで各クラスを呼び出すのはあやしい
         →異なる3つのメソッドを参照してるし、それぞれがどのメソッドを走らせるのかを知っているため。
         →追加されると更に依存度上がる。。
        どうすればいいんだ…
         →引数にクラスを追加したらどうか？
         →依存度が爆増する
        具体的なメソッド名に頼り過ぎてる
        シーケンス図が複雑だとコードももっと複雑になるから気を付けよう。設計がおかしい説が濃厚。
    ダックを見つける
        Tripクラスは単一の目的を果たすためにある。
        Tripクラスのprepareメソッドは旅行の準備をすること(prepare)が目的
         →引数も旅行の準備に費やせばよい
        prepareメソッドは引数が複数のPrepareであることを想定している。
        ```
            class Trip 
                def prepare(preparers)
                    preparers.each do |preparer|
                    preparer.prepare_trip(self)

            class Mechanic
                def prepare_trip(trip)
                    trip.bicycles.each do |bicycle|
                    prepare_bicycle(bicycle)
        ```
    ダックタイピングの影響
        ↑の例は分かりにくそうに見えるけど理解さえすれば一番拡張しやすい。
    Column ポリモーフィズム(polymorphism)
        「poly」 1つのメッセージが多くの
        「morphism」 多数の形態を持っている状態
    5.2 ダックを信頼するコードを書く
        ダックタイプの設計で難しいのは
            ・ダックタイプが必要であることに気付くこと
            ・インターフェースを抽象化すること
    隠れたダックを認識する
        よくあるコーディングパターンでダックタイピングを適応できるもの
            ・クラスで分岐するcase文
            ・kind_of?とis_a?
            ・responds_to?
        ●クラスで分岐するcase文
            prepareが引数のそれぞれから何を望むかを考える。
             →準備する(preapare)は旅行(trip)を準備することを望んでいた。
             →prepare_tripはPreparerダックのパブリックインターフェースとなる。
        ●kind_of?とis_a?
            kind_of_とis_a?はクラスを確認するもの
             →case文みたいな感じ、クラス版のtypeOf()って感じ
        ●responds_to?
            メソッド名版のtypeOf()かな？
    ダックを信頼するコードを書く
        信頼とは、あなたが何をするのか知らない状態
    ダックタイプを文書化する
        例ではいろんなクラスがprepare_tripを実装してるからPreparerっていうまとまりで使える。
        ダックタイプと作る時は
            ・パブリックインターフェースの文書化
            ・テスト
        を書く。
        テストは第9章でやります。
    ダック間でコードを共有する
        第7章でやります。
    賢くダックを選ぶ
        なんでこれはよいコードなのか？
        ```
            #このメソッドには < tt > find(: first) </ tt >メソッドと
            #同じ引数をすべて渡せる
            def first(* args)
                if args. any?
                    if args. first. kind_ of?( Integer) || (loaded?&& !args. first. kind_ of?( Hash))
                            to_ a. first(* args)
                        else
                            apply_ finder_ options( args. first). first
                    end
                    else
                        find_ first
                end
            end
        ```
        IntegerやHashクラスはRubyのコアクラスであり変わることがほぼない安全な依存である。
        判断をしなければならない。
        基本クラスに変更を加える 「モンキーパッチ」という。
         →楽しいらしいが慣れないうちにやるとやばめ。
    5.3 ダックタイピングへの恐れを克服する
    静的型付けによるダックタイプの無効化
        型は変数の中身の分類
        静的型付け言語では変数の型とメソッドの引数は明示的に型を宣言する必要がある。
        静的型付け言語は自己強化で好む人が多いね
    静的型付けと動的型付け
        メタプログラミング 「コードを書くコード」
        静的の利点
            ・コンパイラーがコンパイル時にエラーを見つけてくれる
            ・型情報はドキュメントとしても機能する
            ・コンパイルされたコードは高速に動く
            静的支持者はこう考える
                ・コンパイラが型を検査しない限り、実行時の型エラーが起きる。
                ・型がなければコードを理解できない。実装者はコードを見ただけじゃ型を推測できない。
                ・最適化しなければアプリケーションは遅くなりすぎる。
        動的の利点
            ・コードは逐一実行され、動的に読み込まれる。コンパイラのサイクルがない。
            ・コードは明示的な型情報を持たない。
            ・メタプログラミングより簡単
            動的支持者はこう考える
                ・アプリケーション全体の開発はコンパイラがない方が早い
                ・型宣言がないコードの方が理解が楽。コードから型は推測できる。
                ・メタプログラミングはあることが望ましたい言語機能
    動的型付けを受け入れる
        動的に慣れている人は型付けを疎ましく思う。
        静的に慣れている人は型がないと混乱する。
        メタプログラミングはナイフ、利用者によって便利にも凶器にもなる。
         →メタプログラミング支持者は動的支持者でもあるということ？
        コンパイルは対して価値をもたらしてくれないのにコストが高い？
        動的はコンパイルしないからはるかに効率的
         →ダックタイピングは動的の上に成り立つ。
    まとめ
第6章 継承に余ってふるまいを獲得する
    6.1 クラスによる軽傷を理解する

    6.2 継承を使うべき歌唱を認識する
    具象クラスから始める

    複数の型を埋め込む

    埋め込まれた方を見つける

    継承を選択する

    継承関係を描く

    6.3 軽傷を不適切に適用する

    6.4 抽象を見つける
    抽象的なスーパークラスを作る

    抽象的なふるまいを昇格する

    具象から抽象を分ける

    テンプレートメソッドパターンを使う

    すべてのテンプレートメソッドを実装する

    6.5 スーパークラスとサブクラス間の結合度を管理する
    結合度を理解する

    フックメッセージうぃ使ってサブクラスを疎結合にする

第7章 モジュール間でロールのふるまいを共有する
    責任を管理する

    不必要な依存関係を取り除く

    具体的なコードを書く

    抽象を抽出する

    メソッド探索の仕組み

    ロールのふるまいを継承する

    7.2 継承可能なコードを書く
    アンチパターン

    抽象に固執する

    契約を守る

    テンプレートメソッドパターンを使う

    前もって疎結合にする

    階層構造は浅くする

    7.3 まとめ

第8章 コンポジションでオブジェクトを組み合わせる
    8.1 自転車をパーツからコンポーズする
    Bicycleクラスを更新する

    Parts階層構造を作る

    8.2 Partsオブジェクトをコンポーズする
    Partをつくる

    Partsオブジェクトをもっと配列の様にする

    8.3 Partsを製造する
    PartsFactoryをつくる

    PartsFactoryを活用する

    8.4 コンポーズされたBicycle

    8.5 コンポジションと継承の選択
    継承による影響を認める

    コンポジションの影響を認める

    関係の選択

    8.6 まとめ

第9章 費用対効果の高いテストを設計する
    9.1 意図を持ったテスト
    テストの意図を知る

    何をテストするのか

    いつテストするのか

    テストの方法を知る

    9.2 受信メッセージをテストする
    使われていないインターフェースを削除する

    パブリックインターフェースを証明する

    テスト対象のオブジェクトをか受理する

    クラスを使って依存オブジェクトを注入する

    ロールとして依存オブジェクトを注入する

    9.3 プライベートメソッドをテストする
    テスト中ではプライベートメソッドを無視する

    テスト対象クラスからプライベートメソッドを取り除く

    プライベートメソッドのテストをするという選択

    9.4 送信メッセージをテストする
    クエリメッセージを無視する

    コマンドメッセージを証明する

    9.5 ダックタイプをテストする
    ロールをテストする

    ロールテストを使ったダブルのバリデーション

    9.6 継承されたコードをテストする
    継承されたインターフェースを規定する

    サブクラスの責任を規定する

    固有のふるまいをテストする

    9.7 まとめ

あとがき