第3章 依存関係を管理する
3.1 依存関係を認識するする
依存関係を理解する
    2章終了時点のコード GearのWheelに対する依存は4つある。
    これがあると依存している
        ・GearクラスはWheelクラスの名前を知っている。
        ・GearクラスはWheelクラスがdiameterというメソッドを持っていることを知っている。
        ・GearクラスはWheelクラスをnewするときにrimとtireが引数に必要なことを知っている。
        ・GearクラスはWheelクラスをnewするときに第一引数がrimで第二引数がtireであることを知っている。
    ↑はWheelクラスの変更がGearクラスの変更を強制している。
オブジェクト間の結合(CBO)
    意外とオブジェクト同士で結合してるから1角オブジェクトだけ再利用っていうのができない。
    絡み合ってるから後々めんどうになる。
ほかの依存関係
    初心者の書くテストはコードと結合しすぎてリファクタリングのたびに壊れる。
    依存関係を避けるテクニックを↓で紹介していく。
3.2 疎結合なコードを書く
依存オブジェクトの注入
    ```
    Gearクラス

    def gear_inches
        ratio * wheel.diameter
    end
    ```
    Wheelクラス(インスタンス)に依存している。
    「Wheelインスタンスのギアインチしか計算する意思はない」と宣言してしまっている。
    Gearはdiameterを知るDuckを要求する。
    Gear.new(52, 11, Wheel.new(26, 1.5)).gear_inchs
    オブジェクト@wheelに保有している
依存を隔離する
    Wheelクラスはどこに書けばよいのでしょう？
    WheelのnewをGearのinitializeに書いた(最初に呼び出されるやつ)
     →まだまだ依存している。
     →Gearがwheelに依存していることが明確になった。
     →変更がしやすくなった。
引数の順番への依存を取り除く
    chainring, cog, wheelの引数
    「固定された順番の引数」への依存を簡単に回避する方法。
     →オプションのハッシュ（配列かな）を受け取るようにコードを変える。
     →配列にして渡せってこと
    引数が少ないやつはそのまま使うのがよさそうです。
    明示的にデフォルト値を設定する。「||」の参考演算子を使う。
    論理値(true,false)が渡ってくる引数ならfetchメソッドを使おう。
     →存在しないキーの場合に処理してくれる。
    initializeでデフォルト値を設定して、mergeメソッドで配列をマージする方法もある
     →割と大量の引数を受け取る時とかに有効。
    フレームワークとかで引数固定のものもある。
     →包み隠して使いやすくしてしまおう
    他のオブジェクトを生成する目的のオブジェクトを「ファクトリー」という。
3.3 依存方向の管理
依存関係の逆転
    WheelをGearに依存させる。
    メソッドの引数に渡してみた。
    逆にしても問題なさそうに見えるけど、アプリケーションは変化するからどっちに依存させるかも大事だよね。
依存方向の選択
    「自分より変化しないものに依存しなさい」
    ・あるクラスは、ほかのクラスよりも要件が変わりやすい
    ・具象クラスは抽象クラスよりも変わりやすい
    ・多くのところから依存されたクラスを変更すると、広範囲に影響が及ぶ